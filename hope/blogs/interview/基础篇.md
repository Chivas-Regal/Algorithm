# 基础篇

## 二分查找

### 要求

1. 能够用自己语言描述二分查找算法

2. 能够手写二分查找代码

3. 能够解答一些变化后的考法

### 算法步骤

1. 前提：有已排序数组 A（假设已经做好）

2. 定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步

3. 获取中间索引 $M = Floor((L+R) /2)$

> 注：Floor 向下取整

4. 中间索引的值  $A[M]$ 与待搜索的值 $T$ 进行比较

   1. $A[M] == T$ 表示找到，返回中间索引

   2. $A[M] > T$，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，$M - 1$ 设置为右边界，重新查找

   3. $A[M] < T$，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， $M + 1$ 设置为左边界，重新查找

5. 当 $L > R$ 时，表示没有找到，应结束循环

### 算法实现

> 参考 Java JDK 中 Array.binarySearch 的实现方式

```java
public static void main(String[] args) {
    int[] array = {1, 5, 8, 11, 19, 22, 31, 35, 40, 45, 48, 49, 50};
    int target = 47;
    int idx = binarySearch(array, target);
    System.out.println(idx);
}

public static int binarySearch(int[] a, int t) {
    int l = 0, r = a.length - 1, m;
    while (l <= r) {
        m = (l + r) / 2;
        if (a[m] == t) {
            return m;
        } else if (a[m] > t) {
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}

```

### 解决整数溢出问题

当 l 和 r 都较大时，$l + r$ 有可能超过整数范围，造成运算错误，解决方法有两种：

```java
// 方法一
int m = l + (r - l) / 2;
// 方法二
int m = (l + r) >>> 1;
```

## 冒泡排序

### 要求

1. 能够用自己语言描述冒泡排序算法

2. 能够手写冒泡排序代码

3. 了解一些冒泡排序的优化手段

### 算法描述

1. 依次比较数组中相邻两个元素大小，若 $a[j] > a[j+1]$，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后

2. 重复以上步骤，直到整个数组有序

### 算法实现

```java
public static void bubble(int[] a) {
    for (int j = 0; j < a.length - 1; j++) {
        // 一轮冒泡
        boolean swapped = false; // 是否发生了交换
        for (int i = 0; i < a.length - 1 - j; i++) {
            System.out.println("比较次数" + i);
            if (a[i] > a[i + 1]) {
                Utils.swap(a, i, i + 1);
                swapped = true;
            }
        }
        System.out.println("第" + j + "轮冒泡" + Arrays.toString(a));
        if (!swapped) {
            break;
        }
    }
}
```

优化点1：每经过一轮冒泡，内层循环就可以减少一次
优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环

**进一步优化**

```java
public static void bubble_v2(int[] a) {
    int n = a.length - 1;
    while (true) {
        int last = 0; // 表示最后一次交换索引位置
        for (int i = 0; i < n; i++) {
            System.out.println("比较次数" + i);
            if (a[i] > a[i + 1]) {
                Utils.swap(a, i, i + 1);
                last = i;
            }
        }
        n = last;
        System.out.println("第轮冒泡"
                           + Arrays.toString(a));
        if (n == 0) {
            break;
        }
    }
}
```

每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可

### 完整代码

```java
public class BubbleSort {
    public static void main(String[] args) {
        int[] a = {5, 9, 3, 2, 4, 1, 6, 7, 8};
//        int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        bubble(a);
        System.out.println(Arrays.toString(a));
    }

    public static void bubble(int[] a) {
        int length = a.length - 1;
        while (true) {
            int count = 1;
            int last_swap_index = 0;
            boolean tag = false; // 优化冒泡次数
            for (int i = 0; i < length; i++) {
                System.out.println("比较次数" + i);
                if (a[i] > a[i + 1]) {
                    System.out.println("\t交换次数" + count++);
                    swap(a, i, i + 1);
                    last_swap_index = i;
                }
            }
            length = last_swap_index;
            System.out.println("第轮冒泡" + Arrays.toString(a));
            if (length == 0) break;
        }
    }

    public static void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

## 选择排序

### 要求

1. 能够用自己语言描述选择排序算法

2. 能够比较选择排序与冒泡排序

3. 理解非稳定排序与稳定排序

### 算法描述

1. 将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集

2. 重复以上步骤，直到整个数组有序

> *更形象的描述请参考：selection_sort.html*

### 算法实现

```java
public static void selection(int[] a) {
    for (int i = 0; i < a.length - 1; i++) {
        // i 代表每轮选择最小元素要交换到的目标索引
        int s = i; // 代表最小元素的索引
        for (int j = s + 1; j < a.length; j++) {
            if (a[s] > a[j]) { // j 元素比 s 元素还要小, 更新 s
                s = j;
            }
        }
        if (s != i) {
            swap(a, s, i);
        }
        System.out.println(Arrays.toString(a));
    }
}
```

* 优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素

### 与冒泡排序比较

1. 二者平均时间复杂度都是 $O(n^2)$

2. 选择排序一般要快于冒泡，因为其交换次数少

3. 但如果集合有序度高，冒泡优于选择

4. 冒泡属于稳定排序算法，而选择属于不稳定排序

    1. 稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序

    2. 不稳定排序则反之

### 稳定排序与不稳定排序

```java
System.out.println("=================不稳定================");
Card[] cards = getStaticCards();
System.out.println(Arrays.toString(cards));
selection(cards, Comparator.comparingInt((Card a) -> a.sharpOrder).reversed());
System.out.println(Arrays.toString(cards));
selection(cards, Comparator.comparingInt((Card a) -> a.numberOrder).reversed());
System.out.println(Arrays.toString(cards));

System.out.println("=================稳定=================");
cards = getStaticCards();
System.out.println(Arrays.toString(cards));
bubble(cards, Comparator.comparingInt((Card a) -> a.sharpOrder).reversed());
System.out.println(Arrays.toString(cards));
bubble(cards, Comparator.comparingInt((Card a) -> a.numberOrder).reversed());
System.out.println(Arrays.toString(cards));
```

都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ...）

* 不稳定排序算法按数字排序时，会打乱原本同值的花色顺序

  ```json
  [[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]
  [[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]
  ```

  原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了

* 稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变

  ```json
  [[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]
  [[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]
  ```

## ArrayList

### 要求

1. 掌握 ArrayList 扩容规则

### 扩容规则

1. `ArrayList()` 会使用长度为零的数组

2. `ArrayList(int initialCapacity)` 会使用指定容量的数组

3. `public ArrayList(Collection<? extends E> c)` 会使用 `c` 的大小作为数组容量

4. `add(Object o)` 首次扩容为 `10`，再次扩容为上次容量的 `1.5` 倍

5. `addAll(Collection c)` 没有元素时，扩容为 `Math.max(10, 实际元素个数)`，有元素时为 `Math.max(原容量 1.5 倍, 实际元素个数)`

6. 扩大 `1.5` 倍是通过移位运算实现的

```javascript
// 假设 ArrayList 当前大小为 15，以下是它的扩容过程
15 >> 1 => 7
7 + 15 = 22
```

其中第 4 点必须知道，其它几点视个人情况而定

**提示**

1. 要**注意**的是，示例中用反射方式来更直观地反映 ArrayList 的扩容特征，但从 JDK 9 由于模块化的影响，对反射做了较多限制，需要在运行测试代码时添加 VM 参数 `--add-opens java.base/java.util=ALL-UNNAMED` 方能运行通过，后面的例子都有相同问题

## Iterator

1. 掌握什么是 Fail-Fast、什么是 Fail-Safe

Fail-Fast 与 Fail-Safe

1. ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败

2. CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离

## LinkedList

1. 能够说清楚 LinkedList 对比 ArrayList 的区别，并重视纠正部分错误的认知

### LinkedList

1. 基于双向链表，无需连续内存

2. 随机访问慢（要沿着链表遍历）

3. 头尾插入删除性能高

4. 占用内存多

### ArrayList

1. 基于数组，需要连续内存

2. 随机访问快（指根据下标访问）

3. 尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低

4. 可以利用 cpu 缓存，局部性原理

## HashMap

### 要求

1. 掌握 HashMap 的基本数据结构

2. 掌握树化

3. 理解索引计算方法、二次 hash 的意义、容量对索引计算的影响

4. 掌握 put 流程、扩容、扩容因子

5. 理解并发使用 HashMap 可能导致的问题

6. 理解 key 的设计

### 基本数据结构

* 1.7 数组 + 链表
* 1.8 数组 + （链表 | 红黑树）

> 运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令
>
> ```
> java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar
> ```

### 树化与退化

#### 树化意义

1. 红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略

2. hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表

3. hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小

#### 树化规则

1. 当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 >=64，才会进行树化

#### 退化规则

1. 情况1：在扩容时如果拆分树时，树元素个数 <= 6 则会退化链表

2. 情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表

### 索引计算

#### 索引计算方法

1. 首先，计算对象的 hashCode()

2. 再进行调用 HashMap 的 hash() 方法进行二次哈希

    1. 二次 hash() 是为了综合高位数据，让哈希分布更为均匀

3. 最后 & (capacity – 1) 得到索引

#### 数组容量为何是 2 的 n 次幂

1. 计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模
2. 扩容时重新计算索引效率更高： hash & oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap

**注意**

1. 二次 hash 是为了配合 **容量是 2 的 n 次幂** 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash

2. **容量是 2 的 n 次幂** 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable

### put 与扩容

#### put 流程

1. HashMap 是懒惰创建数组的，首次使用才创建数组

2. 计算索引（桶下标）

3. 如果桶下标还没人占用，创建 Node 占位返回

4. 如果桶下标已经有人占用

   1. 已经是 TreeNode 走红黑树的添加或更新逻辑

   2. 是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑

5. 返回前检查容量是否超过阈值，一旦超过进行扩容

#### 1.7 与 1.8 的区别

1. 链表插入节点时，1.7 是头插法，1.8 是尾插法

2. 1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容

3. 1.8 在扩容计算 Node 索引时，会优化

#### 扩容（加载）因子为何默认是 0.75f

1. 在空间占用与查询时间之间取得较好的权衡

2. 大于这个值，空间节省了，但链表就会比较长影响性能

3. 小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多

### 并发问题

#### 扩容死链（1.7 会存在）

1.7 源码如下：

```java
void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
```

1. e 和 next 都是局部变量，用来指向当前节点和下一个节点

2. 线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移

![](https://gitee.com/biliit/pic-go/raw/master/202201021147765.png)

3. 线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移

![](https://gitee.com/biliit/pic-go/raw/master/202201021148143.png)

4. 第一次循环

    1. 循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b

    2. e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）

    3. 当循环结束是 e 会指向 next 也就是 b 节点

![](https://gitee.com/biliit/pic-go/raw/master/202201021148600.png)
5. 第二次循环

    1. next 指向了节点 a

    2. e 头插节点 b

    3. 当循环结束时，e 指向 next 也就是节点 a

![](https://gitee.com/biliit/pic-go/raw/master/202201021149530.png)

6. 第三次循环

    1. next 指向了 null

    2. e 头插节点 a，**a 的 next 指向了 b**（之前 a.next 一直是 null），b 的 next 指向 a，死链已成

    3. 当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出

![](https://gitee.com/biliit/pic-go/raw/master/202201021149234.png)

> 数据错乱（1.7，1.8 都会存在）

### key 的设计

#### key 的设计要求

1. HashMap 的 key 可以为 null，但 Map 的其他实现则不然

2. 作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）

3. key 的 hashCode 应该有良好的散列性

如果 key 可变，例如修改了 age 会导致再次查询时查询不到

```java
public class HashMapMutableKey {
    public static void main(String[] args) {
        HashMap<Student, Object> map = new HashMap<>();
        Student stu = new Student("张三", 18);
        map.put(stu, new Object());

        System.out.println(map.get(stu));

        stu.age = 19;
        System.out.println(map.get(stu));
    }

    static class Student {
        String name;
        int age;

        public Student(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Student student = (Student) o;
            return age == student.age && Objects.equals(name, student.name);
        }

        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }
    }
}
```

#### String 对象的 hashCode() 设计

1. 目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特

2. 字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 

3. 散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$

4. 31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 

    1. 即 $32 ∗h -h $

    2. 即 $2^5  ∗h -h$

    3. 即 $h≪5  -h$

## 单例模式

### 要求

1. 掌握五种单例模式的实现方式

2. 理解为何 DCL 实现时要使用 volatile 修饰静态变量

3. 了解 jdk 中用到单例的场景

### 饿汉式

```java
public class Singleton1 implements Serializable {
    private Singleton1() {
        if (INSTANCE != null) {
            throw new RuntimeException("单例对象不能重复创建");
        }
        System.out.println("private Singleton1()");
    }

    private static final Singleton1 INSTANCE = new Singleton1();

    public static Singleton1 getInstance() {
        return INSTANCE;
    }

    public static void otherMethod() {
        System.out.println("otherMethod()");
    }

    public Object readResolve() {
        return INSTANCE;
    }
}
```

1. 构造方法抛出异常是防止反射破坏单例

2. `readResolve()` 是防止反序列化破坏单例

### 枚举饿汉式

```java
public enum Singleton2 {
    INSTANCE;

    private Singleton2() {
        System.out.println("private Singleton2()");
    }

    @Override
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }

    public static Singleton2 getInstance() {
        return INSTANCE;
    }

    public static void otherMethod() {
        System.out.println("otherMethod()");
    }
}
```

1. 枚举饿汉式能天然防止反射、反序列化破坏单例

### 懒汉式

```java
public class Singleton3 implements Serializable {
    private Singleton3() {
        System.out.println("private Singleton3()");
    }

    private static Singleton3 INSTANCE = null;

    // Singleton3.class
    public static synchronized Singleton3 getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new Singleton3();
        }
        return INSTANCE;
    }

    public static void otherMethod() {
        System.out.println("otherMethod()");
    }

}
```

1. 其实只有首次创建单例对象时才需要同步，但该代码实际上每次调用都会同步

2. 因此有了下面的双检锁改进

### 双检锁懒汉式

```java
public class Singleton4 implements Serializable {
    private Singleton4() {
        System.out.println("private Singleton4()");
    }

    private static volatile Singleton4 INSTANCE = null; // 可见性，有序性

    public static Singleton4 getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton4.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton4();
                }
            }
        }
        return INSTANCE;
    }

    public static void otherMethod() {
        System.out.println("otherMethod()");
    }
}
```

为何必须加 volatile：

1. `INSTANCE = new Singleton4()` 不是原子的，分成 3 步：创建对象、调用构造、给静态变量赋值，其中后两步可能被指令重排序优化，变成先赋值、再调用构造

2. 如果线程1 先执行了赋值，线程2 执行到第一个 `INSTANCE == null` 时发现 INSTANCE 已经不为 null，此时就会返回一个未完全构造的对象

### 内部类懒汉式

```java
public class Singleton5 implements Serializable {
    private Singleton5() {
        System.out.println("private Singleton5()");
    }

    private static class Holder {
        static Singleton5 INSTANCE = new Singleton5();
    }

    public static Singleton5 getInstance() {
        return Holder.INSTANCE;
    }

    public static void otherMethod() {
        System.out.println("otherMethod()");
    }
}
```

1. 避免了双检锁的缺点

### JDK 中单例的体现

1. Runtime 体现了饿汉式单例

2. Console 体现了双检锁懒汉式单例

3. Collections 中的 EmptyNavigableSet 内部类懒汉式单例

4. ReverseComparator.REVERSE_ORDER 内部类懒汉式单例

5. Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例
