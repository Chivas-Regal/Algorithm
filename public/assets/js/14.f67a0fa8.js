(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{569:function(a,s,h){"use strict";h.r(s);var t=h(13),r=Object(t.a)({},(function(){var a=this,s=a.$createElement,h=a._self._c||s;return h("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[h("h1",{attrs:{id:"hash及应用"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash及应用"}},[a._v("#")]),a._v(" Hash及应用")]),a._v(" "),h("blockquote",[h("p",[h("strong",[a._v("任务：")]),h("br"),a._v("\n给定n个整数，请从小到大输出其中前m大的数"),h("br"),a._v("\n输入：每组测试数据有两行，第一行有两个整数n,m（0 < n, m < 1000000)，第二行有n个各不相同，且都处于区间[0, 1000000]的整数"),h("br"),a._v("\n输出：对每组测试数据按从小到大顺序输出前m大的数"),h("br"),a._v(" "),h("strong",[a._v("思想：桶排序")]),h("br"),a._v("\n将数据值与它的位置建立某种关系，使得存储完毕，则排序完毕")])]),a._v(" "),h("blockquote",[h("p",[h("strong",[a._v("加强版")]),h("br"),a._v("\n第二行包含n个各不相同，且都处于区间[-500000, 500000]"),h("br"),a._v(" "),h("strong",[a._v("再加强版")]),h("br"),a._v("\n如果整数允许相同怎么办")])]),a._v(" "),h("h2",{attrs:{id:"hash表-散列表-基本原理"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash表-散列表-基本原理"}},[a._v("#")]),a._v(" Hash表（散列表）基本原理")]),a._v(" "),h("p",[a._v("使用一个下标范围比较大（数据大小的五到十倍）的数组来存储元素，一般通过设计一个函数(Hash函数，即散列函数)，使得每个元素的关键字都与一个函数值（即数组下标）相对应，然后用该数组单元来存储对应元素。"),h("br"),a._v("\n好处：O(1)")]),a._v(" "),h("h2",{attrs:{id:"hash函数构造-除余法"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash函数构造-除余法"}},[a._v("#")]),a._v(" Hash函数构造：除余法")]),a._v(" "),h("p",[a._v("H(k) = k mod p （p一般选取适当大的素数）")]),a._v(" "),h("h2",{attrs:{id:"hash表简介-冲突"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash表简介-冲突"}},[a._v("#")]),a._v(" Hash表简介--冲突")]),a._v(" "),h("p",[a._v("由于不能保证每个元素的关键字与函数值是一一对应的，因此很有可能出现如下情况："),h("br"),a._v("\n“对于不同的元素关键字，Hash函数计算出了相同的函数值”， 这就是产生了所谓的“冲突”"),h("br"),a._v("\n换句话说，冲突就是Hash函数把不同的元素分在了相同的下标单元")]),a._v(" "),h("h2",{attrs:{id:"hash表简介-冲突解决"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash表简介-冲突解决"}},[a._v("#")]),a._v(" Hash表简介--冲突解决")]),a._v(" "),h("p",[a._v("常用方法：线性探测再散列技术"),h("br"),a._v("\n即：当h(k)位置已经储存有元素的时候，依次探查 (h(k) + i) mod S, i = 1, 2, 3...，直到找到空的储存单元为止，其中S为数组长度"),h("br"),a._v("\n特别地，如果将数组扫描一圈仍未发现空单元，则说明Hash表已满，这会带来麻烦，但是该情况完全可以通过扩大数组范围来避免")]),a._v(" "),h("h2",{attrs:{id:"hash表简介-基本操作"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash表简介-基本操作"}},[a._v("#")]),a._v(" Hash表简介--基本操作")]),a._v(" "),h("p",[a._v("Hash表初始化（0或-1或其它）"),h("br"),a._v("\n哈希函数运算"),h("br"),a._v("\n插入元素（包含冲突解决）"),h("br"),a._v("\n定位（需考虑可能冲突的情况）")]),a._v(" "),h("h2",{attrs:{id:"hash小结"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash小结"}},[a._v("#")]),a._v(" Hash小结")]),a._v(" "),h("h3",{attrs:{id:"hash函数评价标准"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash函数评价标准"}},[a._v("#")]),a._v(" Hash函数评价标准：")]),a._v(" "),h("p",[a._v("低冲突率， 易于编码")]),a._v(" "),h("h3",{attrs:{id:"hash函数特点"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash函数特点"}},[a._v("#")]),a._v(" Hash函数特点：")]),a._v(" "),h("p",[a._v("优点：数据存储和查找效率高（几乎是常数时间）"),h("br"),a._v("\n缺点：消耗较多内存（内存很便宜~）")]),a._v(" "),h("h3",{attrs:{id:"hash主要应用"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash主要应用"}},[a._v("#")]),a._v(" Hash主要应用：")]),a._v(" "),h("p",[a._v("查找元素是否属于集合"),h("br"),a._v("\n搜索中的状态表示")])])}),[],!1,null,null,null);s.default=r.exports}}]);