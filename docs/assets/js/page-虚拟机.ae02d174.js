(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{529:function(t,a,v){"use strict";v.r(a);var i=v(1),_=Object(i.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"虚拟机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机"}},[t._v("#")]),t._v(" 虚拟机")]),t._v(" "),v("h2",{attrs:{id:"jvm-内存结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内存结构"}},[t._v("#")]),t._v(" JVM 内存结构")]),t._v(" "),v("h3",{attrs:{id:"要求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ul",[v("li",[t._v("掌握 JVM 内存结构划分")]),t._v(" "),v("li",[t._v("尤其要知道方法区、永久代、元空间的关系")])]),t._v(" "),v("h3",{attrs:{id:"结合一段-java-代码的执行理解内存划分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结合一段-java-代码的执行理解内存划分"}},[t._v("#")]),t._v(" 结合一段 java 代码的执行理解内存划分")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071119700.png",alt:""}})]),t._v(" "),v("ul",[v("li",[t._v("执行 javac 命令编译源代码为字节码")]),t._v(" "),v("li",[t._v("执行 java 命令\n"),v("ol",[v("li",[t._v("创建 JVM，调用类加载子系统加载 class，将类的信息存入"),v("strong",[t._v("方法区")])]),t._v(" "),v("li",[t._v("创建 main 线程，使用的内存区域是 "),v("strong",[t._v("JVM 虚拟机栈")]),t._v("，开始执行 main 方法代码")]),t._v(" "),v("li",[t._v("如果遇到了未见过的类，会继续触发类加载过程，同样会存入"),v("strong",[t._v("方法区")])]),t._v(" "),v("li",[t._v("需要创建对象，会使用"),v("strong",[t._v("堆")]),t._v("内存来存储对象")]),t._v(" "),v("li",[t._v("不再使用的对象，会由"),v("strong",[t._v("垃圾回收器")]),t._v("在内存不足时回收其内存")]),t._v(" "),v("li",[t._v("调用方法时，方法内的局部变量、方法参数所使用的是  "),v("strong",[t._v("JVM 虚拟机栈")]),t._v("中的栈帧内存")]),t._v(" "),v("li",[t._v("调用方法时，先要到"),v("strong",[t._v("方法区")]),t._v("获得到该方法的字节码指令，由"),v("strong",[t._v("解释器")]),t._v("将字节码指令解释为机器码执行")]),t._v(" "),v("li",[t._v("调用方法时，会将要执行的指令行号读到"),v("strong",[t._v("程序计数器")]),t._v("，这样当发生了线程切换，恢复时就可以从中断的位置继续")]),t._v(" "),v("li",[t._v("对于非 java 实现的方法调用，使用内存称为"),v("strong",[t._v("本地方法栈")]),t._v("（见说明）")]),t._v(" "),v("li",[t._v("对于热点方法调用，或者频繁的循环代码，由 "),v("strong",[t._v("JIT 即时编译器")]),t._v("将这些代码编译成机器码缓存，提高执行性能")])])])]),t._v(" "),v("p",[t._v("说明")]),t._v(" "),v("ul",[v("li",[t._v("加粗字体代表了 JVM 虚拟机组件")]),t._v(" "),v("li",[t._v("对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈")])]),t._v(" "),v("h3",{attrs:{id:"会发生内存溢出的区域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#会发生内存溢出的区域"}},[t._v("#")]),t._v(" 会发生内存溢出的区域")]),t._v(" "),v("ul",[v("li",[t._v("不会出现内存溢出的区域 – 程序计数器")]),t._v(" "),v("li",[t._v("出现 OutOfMemoryError 的情况\n"),v("ul",[v("li",[t._v("堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收")]),t._v(" "),v("li",[t._v("方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类")]),t._v(" "),v("li",[t._v("虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时")])])]),t._v(" "),v("li",[t._v("出现 StackOverflowError 的区域\n"),v("ul",[v("li",[t._v("JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用")])])])]),t._v(" "),v("h3",{attrs:{id:"方法区、永久代、元空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法区、永久代、元空间"}},[t._v("#")]),t._v(" 方法区、永久代、元空间")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("方法区")]),t._v("是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等")]),t._v(" "),v("li",[v("strong",[t._v("永久代")]),t._v("是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）")]),t._v(" "),v("li",[v("strong",[t._v("元空间")]),t._v("是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071119658.png",alt:""}})]),t._v(" "),v("p",[t._v("从这张图学到三点")]),t._v(" "),v("ul",[v("li",[t._v("当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间")]),t._v(" "),v("li",[t._v("X，Y 的类元信息是存储于元空间中，无法直接访问")]),t._v(" "),v("li",[t._v("可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071119588.png",alt:""}})]),t._v(" "),v("p",[t._v("从这张图可以学到")]),t._v(" "),v("ul",[v("li",[t._v("堆内存中：当一个"),v("strong",[t._v("类加载器对象")]),t._v("，这个类加载器对象加载的所有"),v("strong",[t._v("类对象")]),t._v("，这些类对象对应的所有"),v("strong",[t._v("实例对象")]),t._v("都没人引用时，GC 时就会对它们占用的对内存进行释放")]),t._v(" "),v("li",[t._v("元空间中：内存释放"),v("strong",[t._v("以类加载器为单位")]),t._v("，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放")])]),t._v(" "),v("h2",{attrs:{id:"jvm-内存参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内存参数"}},[t._v("#")]),t._v(" JVM 内存参数")]),t._v(" "),v("h3",{attrs:{id:"要求-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-2"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ul",[v("li",[t._v("熟悉常见的 JVM 参数，尤其和大小相关的")])]),t._v(" "),v("h3",{attrs:{id:"堆内存-按大小设置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆内存-按大小设置"}},[t._v("#")]),t._v(" 堆内存，按大小设置")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071127067.png",alt:""}})]),t._v(" "),v("p",[t._v("解释：")]),t._v(" "),v("ul",[v("li",[t._v("-Xms 最小堆内存（包括新生代和老年代）")]),t._v(" "),v("li",[t._v("-Xmx 最大对内存（包括新生代和老年代）")]),t._v(" "),v("li",[t._v("通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好")]),t._v(" "),v("li",[t._v("-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制")]),t._v(" "),v("li",[t._v("-Xmn 设置新生代大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等")]),t._v(" "),v("li",[t._v("保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同")])]),t._v(" "),v("h3",{attrs:{id:"堆内存-按比例设置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆内存-按比例设置"}},[t._v("#")]),t._v(" 堆内存，按比例设置")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071127868.png",alt:""}})]),t._v(" "),v("p",[t._v("解释：")]),t._v(" "),v("ul",[v("li",[t._v("-XX:NewRatio=2:1 表示老年代占两份，新生代占一份")]),t._v(" "),v("li",[t._v("-XX:SurvivorRatio=4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份")])]),t._v(" "),v("h3",{attrs:{id:"元空间内存设置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#元空间内存设置"}},[t._v("#")]),t._v(" 元空间内存设置")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071128535.png",alt:""}})]),t._v(" "),v("p",[t._v("解释：")]),t._v(" "),v("ul",[v("li",[t._v("class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制")]),t._v(" "),v("li",[t._v("non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）")]),t._v(" "),v("li",[t._v("class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制")])]),t._v(" "),v("p",[t._v("注意：")]),t._v(" "),v("ul",[v("li",[t._v("这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启")])]),t._v(" "),v("h3",{attrs:{id:"代码缓存内存设置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代码缓存内存设置"}},[t._v("#")]),t._v(" 代码缓存内存设置")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071128424.png",alt:""}})]),t._v(" "),v("p",[t._v("解释：")]),t._v(" "),v("ul",[v("li",[t._v("如果 -XX:ReservedCodeCacheSize < 240m，所有优化机器代码不加区分存在一起")]),t._v(" "),v("li",[t._v("否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）\n"),v("ul",[v("li",[t._v("non-nmethods - JVM 自己用的代码")]),t._v(" "),v("li",[t._v("profiled nmethods - 部分优化的机器码")]),t._v(" "),v("li",[t._v("non-profiled nmethods - 完全优化的机器码")])])])]),t._v(" "),v("h3",{attrs:{id:"线程内存设置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程内存设置"}},[t._v("#")]),t._v(" 线程内存设置")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071128173.png",alt:""}})]),t._v(" "),v("blockquote",[v("p",[v("em",[v("strong",[t._v("官方参考文档")])])]),t._v(" "),v("ul",[v("li",[t._v("https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE")])])]),t._v(" "),v("h2",{attrs:{id:"jvm-垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm-垃圾回收"}},[t._v("#")]),t._v(" JVM 垃圾回收")]),t._v(" "),v("h3",{attrs:{id:"要求-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-3"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ul",[v("li",[t._v("掌握垃圾回收算法")]),t._v(" "),v("li",[t._v("掌握分代回收思想")]),t._v(" "),v("li",[t._v("理解三色标记及漏标处理")]),t._v(" "),v("li",[t._v("了解常见垃圾回收器")])]),t._v(" "),v("h3",{attrs:{id:"三种垃圾回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三种垃圾回收算法"}},[t._v("#")]),t._v(" 三种垃圾回收算法")]),t._v(" "),v("p",[t._v("标记清除法")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071128360.png",alt:""}})]),t._v(" "),v("p",[t._v("解释：")]),t._v(" "),v("ol",[v("li",[t._v("找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象")]),t._v(" "),v("li",[t._v("标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记")]),t._v(" "),v("li",[t._v("清除阶段：释放未加标记的对象占用的内存")])]),t._v(" "),v("p",[t._v("要点：")]),t._v(" "),v("ul",[v("li",[t._v("标记速度与存活对象线性关系")]),t._v(" "),v("li",[t._v("清除速度与内存大小线性关系")]),t._v(" "),v("li",[t._v("缺点是会产生内存碎片")])]),t._v(" "),v("p",[t._v("标记整理法")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071129695.png",alt:""}})]),t._v(" "),v("p",[t._v("解释：")]),t._v(" "),v("ol",[v("li",[t._v("前面的标记阶段、清理阶段与标记清除法类似")]),t._v(" "),v("li",[t._v("多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生")])]),t._v(" "),v("p",[t._v("特点：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("标记速度与存活对象线性关系")])]),t._v(" "),v("li",[v("p",[t._v("清除与整理速度与内存大小成线性关系")])]),t._v(" "),v("li",[v("p",[t._v("缺点是性能上较慢")])])]),t._v(" "),v("p",[t._v("标记复制法")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071129958.png",alt:""}})]),t._v(" "),v("p",[t._v("解释：")]),t._v(" "),v("ol",[v("li",[t._v("将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象")]),t._v(" "),v("li",[t._v("标记阶段与前面的算法类似")]),t._v(" "),v("li",[t._v("在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理")]),t._v(" "),v("li",[t._v("复制完成后，交换 from 和 to 的位置即可")])]),t._v(" "),v("p",[t._v("特点：")]),t._v(" "),v("ul",[v("li",[t._v("标记与复制速度与存活对象成线性关系")]),t._v(" "),v("li",[t._v("缺点是会占用成倍的空间")])]),t._v(" "),v("h3",{attrs:{id:"gc-与分代回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc-与分代回收算法"}},[t._v("#")]),t._v(" GC 与分代回收算法")]),t._v(" "),v("p",[t._v("GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度")]),t._v(" "),v("p",[t._v("GC 要点：")]),t._v(" "),v("ul",[v("li",[t._v("回收区域是"),v("strong",[t._v("堆内存")]),t._v("，不包括虚拟机栈")]),t._v(" "),v("li",[t._v("判断无用对象，使用"),v("strong",[t._v("可达性分析算法")]),t._v("，"),v("strong",[t._v("三色标记法")]),t._v("标记存活对象，回收未标记对象")]),t._v(" "),v("li",[t._v("GC 具体的实现称为"),v("strong",[t._v("垃圾回收器")])]),t._v(" "),v("li",[t._v("GC 大都采用了"),v("strong",[t._v("分代回收思想")]),t._v(" "),v("ul",[v("li",[t._v("理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收")]),t._v(" "),v("li",[t._v("根据这两类对象的特性将回收区域分为"),v("strong",[t._v("新生代")]),t._v("和"),v("strong",[t._v("老年代")]),t._v("，新生代采用标记复制法、老年代一般采用标记整理法")])])]),t._v(" "),v("li",[t._v("根据 GC 的规模可以分成 "),v("strong",[t._v("Minor GC")]),t._v("，"),v("strong",[t._v("Mixed GC")]),t._v("，"),v("strong",[t._v("Full GC")])])]),t._v(" "),v("h3",{attrs:{id:"分代回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分代回收"}},[t._v("#")]),t._v(" 分代回收")]),t._v(" "),v("ol",[v("li",[t._v("伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071129240.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071129589.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071130072.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("将 from 和 to 交换位置")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071130845.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("经过一段时间后伊甸园的内存又出现不足")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071130915.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[t._v("标记伊甸园与 from（现阶段没有）的存活对象")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071130701.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"7"}},[v("li",[t._v("将存活对象采用复制算法复制到 to 中")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071130562.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"8"}},[v("li",[t._v("复制完毕后，伊甸园和 from 内存都得到释放")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071131113.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"9"}},[v("li",[t._v("将 from 和 to 交换位置")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071131342.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"10"}},[v("li",[t._v("老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）")])]),t._v(" "),v("h3",{attrs:{id:"gc-规模"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc-规模"}},[t._v("#")]),t._v(" GC 规模")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Minor GC 发生在新生代的垃圾回收，暂停时间短")])]),t._v(" "),v("li",[v("p",[t._v("Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有")])]),t._v(" "),v("li",[v("p",[t._v("Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，"),v("strong",[t._v("应尽力避免")])])])]),t._v(" "),v("h3",{attrs:{id:"三色标记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三色标记"}},[t._v("#")]),t._v(" 三色标记")]),t._v(" "),v("p",[t._v("即用三种颜色记录对象的标记状态")]),t._v(" "),v("ul",[v("li",[t._v("黑色 – 已标记")]),t._v(" "),v("li",[t._v("灰色 – 标记中")]),t._v(" "),v("li",[t._v("白色 – 还未标记")])]),t._v(" "),v("ol",[v("li",[t._v("起始的三个对象还未处理完成，用灰色表示")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071131396.png"}}),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071132663.png"}}),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("依次类推")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071133347.png"}}),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("沿着引用链都标记了一遍")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071133347.png"}}),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("最后为标记的白色对象，即为垃圾")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071715328.png"}}),t._v(" "),v("h3",{attrs:{id:"并发漏标问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发漏标问题"}},[t._v("#")]),t._v(" 并发漏标问题")]),t._v(" "),v("p",[t._v("比较先进的垃圾回收器都支持"),v("strong",[t._v("并发标记")]),t._v("，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：")]),t._v(" "),v("ol",[v("li",[t._v("如图所示标记工作尚未完成")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071715889.png"}}),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071716383.png"}}),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071716978.png"}}),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071717425.png"}}),t._v(" "),v("p",[t._v("因此对于"),v("strong",[t._v("并发标记")]),t._v("而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：")]),t._v(" "),v("ol",[v("li",[t._v("Incremental Update 增量更新法，CMS 垃圾回收器采用\n"),v("ul",[v("li",[t._v("思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍")])])]),t._v(" "),v("li",[t._v("Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用\n"),v("ul",[v("li",[t._v("思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理")]),t._v(" "),v("li",[t._v("新加对象会被记录")]),t._v(" "),v("li",[t._v("被删除引用关系的对象也被记录")])])])]),t._v(" "),v("h3",{attrs:{id:"垃圾回收器-parallel-gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器-parallel-gc"}},[t._v("#")]),t._v(" 垃圾回收器 - Parallel GC")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程")])]),t._v(" "),v("li",[v("p",[t._v("old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("注重吞吐量")])])])]),t._v(" "),v("h3",{attrs:{id:"垃圾回收器-concurrentmarksweep-gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器-concurrentmarksweep-gc"}},[t._v("#")]),t._v(" 垃圾回收器 - ConcurrentMarkSweep GC")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("它是工作在 old 老年代，支持"),v("strong",[t._v("并发标记")]),t._v("的一款回收器，采用"),v("strong",[t._v("并发清除")]),t._v("算法")]),t._v(" "),v("ul",[v("li",[t._v("并发标记时不需暂停用户线程")]),t._v(" "),v("li",[t._v("重新标记时仍需暂停用户线程")])])]),t._v(" "),v("li",[v("p",[t._v("如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("注重响应时间")])])])]),t._v(" "),v("h3",{attrs:{id:"垃圾回收器-g1-gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器-g1-gc"}},[t._v("#")]),t._v(" 垃圾回收器 - G1 GC")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("响应时间与吞吐量兼顾")])]),t._v(" "),v("li",[t._v("划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备")]),t._v(" "),v("li",[t._v("分成三个阶段：新生代回收、并发标记、混合收集")]),t._v(" "),v("li",[t._v("如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC")])]),t._v(" "),v("h3",{attrs:{id:"g1-回收阶段-新生代回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#g1-回收阶段-新生代回收"}},[t._v("#")]),t._v(" G1 回收阶段 - 新生代回收")]),t._v(" "),v("ol",[v("li",[t._v("初始时，所有区域都处于空闲状态")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071718179.png"}}),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071718995.png"}}),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071719119.png"}}),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("复制完成，将之前的伊甸园内存释放")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071719513.png"}}),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("随着时间流逝，伊甸园的内存又有不足")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071720938.png"}}),t._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[t._v("将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071723542.png"}}),t._v(" "),v("ol",{attrs:{start:"7"}},[v("li",[t._v("释放伊甸园以及之前幸存区的内存")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071723089.png"}}),t._v(" "),v("h3",{attrs:{id:"g1-回收阶段-并发标记与混合收集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#g1-回收阶段-并发标记与混合收集"}},[t._v("#")]),t._v(" G1 回收阶段 - 并发标记与混合收集")]),t._v(" "),v("ol",[v("li",[t._v("当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071724516.png"}}),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据"),v("strong",[t._v("暂停时间目标")]),t._v("优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071732366.png"}}),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071724341.png"}}),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("下图显示了老年代和幸存区晋升的存活对象的复制")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071725727.png"}}),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集")])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071725261.png"}}),t._v(" "),v("h2",{attrs:{id:"内存溢出"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存溢出"}},[t._v("#")]),t._v(" 内存溢出")]),t._v(" "),v("h3",{attrs:{id:"要求-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-4"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ul",[v("li",[t._v("能够说出几种典型的导致内存溢出的情况")])]),t._v(" "),v("h3",{attrs:{id:"典型情况"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#典型情况"}},[t._v("#")]),t._v(" 典型情况")]),t._v(" "),v("ul",[v("li",[t._v("误用线程池导致的内存溢出\n"),v("ul",[v("li",[t._v("参考 day03.TestOomThreadPool")])])]),t._v(" "),v("li",[t._v("查询数据量太大导致的内存溢出\n"),v("ul",[v("li",[t._v("参考 day03.TestOomTooManyObject")])])]),t._v(" "),v("li",[t._v("动态生成类导致的内存溢出\n"),v("ul",[v("li",[t._v("参考 day03.TestOomTooManyClass")])])])]),t._v(" "),v("h2",{attrs:{id:"类加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载"}},[t._v("#")]),t._v(" 类加载")]),t._v(" "),v("h3",{attrs:{id:"要求-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-5"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ul",[v("li",[t._v("掌握类加载阶段")]),t._v(" "),v("li",[t._v("掌握类加载器")]),t._v(" "),v("li",[t._v("理解双亲委派机制")])]),t._v(" "),v("h3",{attrs:{id:"类加载过程的三个阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程的三个阶段"}},[t._v("#")]),t._v(" 类加载过程的三个阶段")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("加载")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("将类的字节码载入方法区，并创建类.class 对象")])]),t._v(" "),v("li",[v("p",[t._v("如果此类的父类没有加载，先加载父类")])]),t._v(" "),v("li",[v("p",[t._v("加载是懒惰执行")])])])]),t._v(" "),v("li",[v("p",[t._v("链接")]),t._v(" "),v("ol",[v("li",[t._v("验证 – 验证类是否符合 Class 规范，合法性、安全性检查")]),t._v(" "),v("li",[t._v("准备 – 为 static 变量分配空间，设置默认值")]),t._v(" "),v("li",[t._v("解析 – 将常量池的符号引用解析为直接引用")])])]),t._v(" "),v("li",[v("p",[t._v("初始化")]),t._v(" "),v("ol",[v("li",[t._v("静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 "),v("code",[t._v("<cinit>")]),t._v(" 方法，在初始化时被调用")]),t._v(" "),v("li",[t._v("static final 修饰的基本类型变量赋值，在链接阶段就已完成")]),t._v(" "),v("li",[t._v("初始化是懒惰执行")])])])]),t._v(" "),v("blockquote",[v("p",[v("em",[v("strong",[t._v("验证手段")])])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("使用 jps 查看进程号")])]),t._v(" "),v("li",[v("p",[t._v("使用 jhsdb 调试，执行命令 "),v("code",[t._v("jhsdb.exe hsdb")]),t._v(" 打开它的图形界面")]),t._v(" "),v("ul",[v("li",[t._v("Class Browser 可以查看当前 jvm 中加载了哪些类")]),t._v(" "),v("li",[t._v("控制台的 universe 命令查看堆内存范围")]),t._v(" "),v("li",[t._v("控制台的 g1regiondetails 命令查看 region 详情")]),t._v(" "),v("li",[v("code",[t._v("scanoops 起始地址 结束地址 对象类型")]),t._v(" 可以根据类型查找某个区间内的对象地址")]),t._v(" "),v("li",[t._v("控制台的 "),v("code",[t._v("inspect 地址")]),t._v(" 指令能够查看这个地址对应的对象详情")])])]),t._v(" "),v("li",[v("p",[t._v("使用 javap 命令可以查看 class 字节码\n"),v("em",[v("strong",[t._v("代码说明")])])])]),t._v(" "),v("li",[v("p",[t._v("day03.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载")])]),t._v(" "),v("li",[v("p",[t._v("day03.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载")])])])]),t._v(" "),v("h3",{attrs:{id:"jdk-8-的类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jdk-8-的类加载器"}},[t._v("#")]),t._v(" jdk 8 的类加载器")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[t._v("名称")])]),t._v(" "),v("th",[v("strong",[t._v("加载哪的类")])]),t._v(" "),v("th",[v("strong",[t._v("说明")])])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Bootstrap ClassLoader")]),t._v(" "),v("td",[t._v("JAVA_HOME/jre/lib")]),t._v(" "),v("td",[t._v("无法直接访问")])]),t._v(" "),v("tr",[v("td",[t._v("Extension ClassLoader")]),t._v(" "),v("td",[t._v("JAVA_HOME/jre/lib/ext")]),t._v(" "),v("td",[t._v("上级为 Bootstrap，显示为  null")])]),t._v(" "),v("tr",[v("td",[t._v("Application ClassLoader")]),t._v(" "),v("td",[t._v("classpath")]),t._v(" "),v("td",[t._v("上级为 Extension")])]),t._v(" "),v("tr",[v("td",[t._v("自定义类加载器")]),t._v(" "),v("td",[t._v("自定义")]),t._v(" "),v("td",[t._v("上级为 Application")])])])]),t._v(" "),v("h3",{attrs:{id:"双亲委派机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[t._v("#")]),t._v(" 双亲委派机制")]),t._v(" "),v("p",[t._v("所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器")]),t._v(" "),v("ul",[v("li",[t._v("能找到这个类，由上级加载，加载后该类也对下级加载器可见")]),t._v(" "),v("li",[t._v("找不到这个类，则下级类加载器才有资格执行加载")])]),t._v(" "),v("p",[t._v("双亲委派的目的有两点")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类")])]),t._v(" "),v("li",[v("p",[t._v("让类的加载有优先次序，保证核心类优先加载")])])]),t._v(" "),v("h3",{attrs:{id:"对双亲委派的误解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对双亲委派的误解"}},[t._v("#")]),t._v(" 对双亲委派的误解")]),t._v(" "),v("p",[t._v("下面面试题的回答是错误的")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071735306.png",alt:""}})]),t._v(" "),v("p",[t._v("错在哪了？")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。")])]),t._v(" "),v("li",[v("p",[t._v("假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的")])]),t._v(" "),v("li",[v("p",[t._v("假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("以上也仅仅是假设")]),t._v("。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了")])])]),t._v(" "),v("blockquote",[v("p",[v("em",[v("strong",[t._v("代码说明")])])]),t._v(" "),v("ul",[v("li",[t._v("day03.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系")])])]),t._v(" "),v("h2",{attrs:{id:"四种引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四种引用"}},[t._v("#")]),t._v(" 四种引用")]),t._v(" "),v("h3",{attrs:{id:"要求-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-6"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ul",[v("li",[t._v("掌握四种引用")])]),t._v(" "),v("h3",{attrs:{id:"强引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强引用"}},[t._v("#")]),t._v(" 强引用")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("普通变量赋值即为强引用，如 A a = new A();")])]),t._v(" "),v("li",[v("p",[t._v("通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收")])])]),t._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071727417.png"}}),t._v(" "),v("h3",{attrs:{id:"软引用-softreference"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软引用-softreference"}},[t._v("#")]),t._v(" 软引用（SoftReference）")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("例如：SoftReference a = new SoftReference(new A());")])]),t._v(" "),v("li",[v("p",[t._v("如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象")])]),t._v(" "),v("li",[v("p",[t._v("软引用自身需要配合引用队列来释放")])]),t._v(" "),v("li",[v("p",[t._v("典型例子是反射数据")])])]),t._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071728914.png"}}),t._v(" "),v("h3",{attrs:{id:"弱引用-weakreference"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#弱引用-weakreference"}},[t._v("#")]),t._v(" 弱引用（WeakReference）")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("例如：WeakReference a = new WeakReference(new A());")])]),t._v(" "),v("li",[v("p",[t._v("如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象")])]),t._v(" "),v("li",[v("p",[t._v("弱引用自身需要配合引用队列来释放")])]),t._v(" "),v("li",[v("p",[t._v("典型例子是 ThreadLocalMap 中的 Entry 对象")])])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071728727.png"}}),t._v(" "),v("h3",{attrs:{id:"虚引用-phantomreference"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚引用-phantomreference"}},[t._v("#")]),t._v(" 虚引用（PhantomReference）")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("例如： PhantomReference a = new PhantomReference(new A(), referenceQueue);")])]),t._v(" "),v("li",[v("p",[t._v("必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理")])]),t._v(" "),v("li",[v("p",[t._v("典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存")])])]),t._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071729725.png"}}),t._v(" "),v("blockquote",[v("p",[v("em",[v("strong",[t._v("代码说明")])])]),t._v(" "),v("ul",[v("li",[t._v("day03.reference.TestPhantomReference - 演示虚引用的基本用法")]),t._v(" "),v("li",[t._v("day03.reference.TestWeakReference - 模拟 ThreadLocalMap, 采用引用队列释放 entry 内存")])])]),t._v(" "),v("h2",{attrs:{id:"finalize"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finalize"}},[t._v("#")]),t._v(" finalize")]),t._v(" "),v("h3",{attrs:{id:"要求-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-7"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ul",[v("li",[t._v("掌握 finalize 的工作原理与缺点")])]),t._v(" "),v("h3",{attrs:{id:"finalize-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finalize-2"}},[t._v("#")]),t._v(" finalize")]),t._v(" "),v("ul",[v("li",[t._v("它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作")]),t._v(" "),v("li",[t._v("将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了")])]),t._v(" "),v("h3",{attrs:{id:"finalize-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finalize-原理"}},[t._v("#")]),t._v(" finalize 原理")]),t._v(" "),v("ol",[v("li",[t._v("对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）")]),t._v(" "),v("li",[t._v("当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071730959.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列")]),t._v(" "),v("li",[t._v("但此时 Dog 对象还没法被立刻回收，因为 unfinalized -> Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】")]),t._v(" "),v("li",[t._v("FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201071730793.png",alt:""}})]),t._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[t._v("由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了")])]),t._v(" "),v("h3",{attrs:{id:"finalize-缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finalize-缺点"}},[t._v("#")]),t._v(" finalize 缺点")]),t._v(" "),v("ul",[v("li",[t._v("无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了")]),t._v(" "),v("li",[t._v("无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）")]),t._v(" "),v("li",[t._v("内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存")]),t._v(" "),v("li",[t._v("有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致")])]),t._v(" "),v("blockquote",[v("p",[v("em",[v("strong",[t._v("代码说明")])])]),t._v(" "),v("ul",[v("li",[t._v("day03.reference.TestFinalize - finalize 的测试代码")])])])])}),[],!1,null,null,null);a.default=_.exports}}]);