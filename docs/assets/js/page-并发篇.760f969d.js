(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{527:function(t,a,v){"use strict";v.r(a);var _=v(1),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"并发篇"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发篇"}},[t._v("#")]),t._v(" 并发篇")]),t._v(" "),v("h2",{attrs:{id:"线程状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程状态"}},[t._v("#")]),t._v(" 线程状态")]),t._v(" "),v("h3",{attrs:{id:"要求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("掌握 Java 线程六种状态")])]),t._v(" "),v("li",[v("p",[t._v("掌握 Java 线程状态转换")])]),t._v(" "),v("li",[v("p",[t._v("能理解五种状态与六种状态两种说法的区别")])])]),t._v(" "),v("h3",{attrs:{id:"六种状态及转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六种状态及转换"}},[t._v("#")]),t._v(" 六种状态及转换")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201040920672.png",alt:""}})]),t._v(" "),v("p",[t._v("分别是")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("新建")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("当一个线程对象被创建，但还未调用 start 方法时处于"),v("strong",[t._v("新建")]),t._v("状态")])]),t._v(" "),v("li",[v("p",[t._v("此时未与操作系统底层线程关联")])])])]),t._v(" "),v("li",[v("p",[t._v("可运行")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("调用了 start 方法，就会由"),v("strong",[t._v("新建")]),t._v("进入"),v("strong",[t._v("可运行")])])]),t._v(" "),v("li",[v("p",[t._v("此时与底层线程关联，由操作系统调度执行")])])])]),t._v(" "),v("li",[v("p",[t._v("终结")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("线程内代码已经执行完毕，由"),v("strong",[t._v("可运行")]),t._v("进入"),v("strong",[t._v("终结")])])]),t._v(" "),v("li",[v("p",[t._v("此时会取消与底层线程关联")])])])]),t._v(" "),v("li",[v("p",[t._v("阻塞")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("当获取锁失败后，由"),v("strong",[t._v("可运行")]),t._v("进入 Monitor 的阻塞队列"),v("strong",[t._v("阻塞")]),t._v("，此时不占用 cpu 时间")])]),t._v(" "),v("li",[v("p",[t._v("当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的"),v("strong",[t._v("阻塞")]),t._v("线程，唤醒后的线程进入"),v("strong",[t._v("可运行")]),t._v("状态")])])])]),t._v(" "),v("li",[v("p",[t._v("等待")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从"),v("strong",[t._v("可运行")]),t._v("状态释放锁进入 Monitor 等待集合"),v("strong",[t._v("等待")]),t._v("，同样不占用 cpu 时间")])]),t._v(" "),v("li",[v("p",[t._v("当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的"),v("strong",[t._v("等待")]),t._v("线程，恢复为"),v("strong",[t._v("可运行")]),t._v("状态")])])])]),t._v(" "),v("li",[v("p",[t._v("有时限等待")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从"),v("strong",[t._v("可运行")]),t._v("状态释放锁进入 Monitor 等待集合进行"),v("strong",[t._v("有时限等待")]),t._v("，同样不占用 cpu 时间")])]),t._v(" "),v("li",[v("p",[t._v("当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的"),v("strong",[t._v("有时限等待")]),t._v("线程，恢复为"),v("strong",[t._v("可运行")]),t._v("状态，并重新去竞争锁")])]),t._v(" "),v("li",[v("p",[t._v("如果等待超时，也会从"),v("strong",[t._v("有时限等待")]),t._v("状态恢复为"),v("strong",[t._v("可运行")]),t._v("状态，并重新去竞争锁")])]),t._v(" "),v("li",[v("p",[t._v("还有一种情况是调用 sleep(long) 方法也会从"),v("strong",[t._v("可运行")]),t._v("状态进入"),v("strong",[t._v("有时限等待")]),t._v("状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为"),v("strong",[t._v("可运行")]),t._v("状态")])])])])]),t._v(" "),v("blockquote",[v("p",[v("em",[v("strong",[t._v("其它情况（只需了解）")])])]),t._v(" "),v("ul",[v("li",[t._v("可以用 interrupt() 方法打断"),v("strong",[t._v("等待")]),t._v("、"),v("strong",[t._v("有时限等待")]),t._v("的线程，让它们恢复为"),v("strong",[t._v("可运行")]),t._v("状态")]),t._v(" "),v("li",[t._v("park，unpark 等方法也可以让线程等待和唤醒")])])]),t._v(" "),v("h3",{attrs:{id:"五种状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五种状态"}},[t._v("#")]),t._v(" 五种状态")]),t._v(" "),v("p",[t._v("五种状态的说法来自于操作系统层面的划分")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201040920941.png",alt:""}})]),t._v(" "),v("ol",[v("li",[v("p",[t._v("运行态：分到 cpu 时间，能真正执行线程内代码的")])]),t._v(" "),v("li",[v("p",[t._v("就绪态：有资格分到 cpu 时间，但还未轮到它的")])]),t._v(" "),v("li",[v("p",[t._v("阻塞态：没资格分到 cpu 时间的")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("涵盖了 java 状态中提到的"),v("strong",[t._v("阻塞")]),t._v("、"),v("strong",[t._v("等待")]),t._v("、"),v("strong",[t._v("有时限等待")])])]),t._v(" "),v("li",[v("p",[t._v("多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等")])]),t._v(" "),v("li",[v("p",[t._v("新建与终结态：与 java 中同名状态类似，不再啰嗦")])])])])]),t._v(" "),v("h2",{attrs:{id:"线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[t._v("#")]),t._v(" 线程池")]),t._v(" "),v("h3",{attrs:{id:"要求-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-2"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ol",[v("li",[t._v("掌握线程池的 7 大核心参数")])]),t._v(" "),v("h3",{attrs:{id:"七大参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七大参数"}},[t._v("#")]),t._v(" 七大参数")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("corePoolSize 核心线程数目 - 池中会保留的最多线程数")])]),t._v(" "),v("li",[v("p",[t._v("maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目")])]),t._v(" "),v("li",[v("p",[t._v("keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放")])]),t._v(" "),v("li",[v("p",[t._v("unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等")])]),t._v(" "),v("li",[v("p",[t._v("workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务")])]),t._v(" "),v("li",[v("p",[t._v("threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等")])]),t._v(" "),v("li",[v("p",[t._v("handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy")])]),t._v(" "),v("li",[v("p",[t._v("由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy")])]),t._v(" "),v("li",[v("p",[t._v("丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy")])]),t._v(" "),v("li",[v("p",[t._v("丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy")])])])])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/biliit/pic-go/raw/master/202201040921944.png",alt:""}})]),t._v(" "),v("h2",{attrs:{id:"wait-vs-sleep"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#wait-vs-sleep"}},[t._v("#")]),t._v(" wait vs sleep")]),t._v(" "),v("h3",{attrs:{id:"要求-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-3"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ol",[v("li",[t._v("能够说出二者区别")])]),t._v(" "),v("h3",{attrs:{id:"一个共同点-三个不同点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一个共同点-三个不同点"}},[t._v("#")]),t._v(" 一个共同点，三个不同点")]),t._v(" "),v("p",[t._v("共同点")]),t._v(" "),v("ol",[v("li",[t._v("wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入"),v("strong",[t._v("阻塞")]),t._v("状态")])]),t._v(" "),v("p",[t._v("不同点")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("方法归属不同")]),t._v(" "),v("ol",[v("li",[v("p",[v("code",[t._v("sleep(long)")]),t._v(" 是 "),v("code",[t._v("Thread")]),t._v(" 的静态方法")])]),t._v(" "),v("li",[v("p",[t._v("而 "),v("code",[t._v("wait()")]),t._v("，"),v("code",[t._v("wait(long)")]),t._v(" 都是 "),v("code",[t._v("Object")]),t._v(" 的成员方法，每个对象都有")])])])]),t._v(" "),v("li",[v("p",[t._v("醒来时机不同")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("执行 "),v("code",[t._v("sleep(long)")]),t._v(" 和 "),v("code",[t._v("wait(long)")]),t._v(" 的线程都会在等待相应毫秒后醒来")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("wait(long)")]),t._v(" 和 "),v("code",[t._v("wait()")]),t._v(" 还可以被 "),v("code",[t._v("notify")]),t._v(" 唤醒，"),v("code",[t._v("wait()")]),t._v(" 如果不唤醒就一直等下去")])]),t._v(" "),v("li",[v("p",[t._v("它们都可以被打断唤醒")])])])]),t._v(" "),v("li",[v("p",[t._v("锁特性不同（重点）")]),t._v(" "),v("ol",[v("li",[v("p",[v("code",[t._v("wait")]),t._v(" 方法的调用必须先获取 "),v("code",[t._v("wait")]),t._v(" 对象的锁，而 "),v("code",[t._v("sleep")]),t._v(" 则无此限制")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("wait")]),t._v(" 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 "),v("code",[t._v("cpu")]),t._v("，但你们还可以用）")])]),t._v(" "),v("li",[v("p",[t._v("而 "),v("code",[t._v("sleep")]),t._v(" 如果在 "),v("code",[t._v("synchronized")]),t._v(" 代码块中执行，并不会释放对象锁（我放弃 "),v("code",[t._v("cpu")]),t._v("，你们也用不了）")])])])])]),t._v(" "),v("h2",{attrs:{id:"lock-vs-synchronized"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lock-vs-synchronized"}},[t._v("#")]),t._v(" lock vs synchronized")]),t._v(" "),v("h3",{attrs:{id:"要求-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-4"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("掌握 lock 与 synchronized 的区别")])]),t._v(" "),v("li",[v("p",[t._v("理解 ReentrantLock 的公平、非公平锁")])]),t._v(" "),v("li",[v("p",[t._v("理解 ReentrantLock 中的条件变量")])])]),t._v(" "),v("h3",{attrs:{id:"三个层面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三个层面"}},[t._v("#")]),t._v(" 三个层面")]),t._v(" "),v("p",[t._v("不同点")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("语法层面")]),t._v(" "),v("ol",[v("li",[v("p",[v("code",[t._v("synchronized")]),t._v(" 是关键字，源码在 "),v("code",[t._v("jvm")]),t._v(" 中，用 "),v("code",[t._v("c++")]),t._v(" 语言实现")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Lock")]),t._v(" 是接口，源码由 "),v("code",[t._v("jdk")]),t._v(" 提供，用 "),v("code",[t._v("java")]),t._v(" 语言实现")])]),t._v(" "),v("li",[v("p",[t._v("使用 "),v("code",[t._v("synchronized")]),t._v(" 时，退出同步代码块锁会自动释放，而使用 "),v("code",[t._v("Lock")]),t._v(" 时，需要手动调用 "),v("code",[t._v("unlock")]),t._v(" 方法释放锁")])])])]),t._v(" "),v("li",[v("p",[t._v("功能层面")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("二者均属于悲观锁、都具备基本的"),v("strong",[t._v("互斥、同步、锁重入")]),t._v("功能")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Lock")]),t._v(" 提供了许多 "),v("code",[t._v("synchronized")]),t._v(" 不具备的功能，例如"),v("strong",[t._v("获取等待状态、公平锁、可打断、可超时、多条件变量")])])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Lock")]),t._v(" 有适合不同场景的实现，如 "),v("code",[t._v("ReentrantLock")]),t._v("、 "),v("code",[t._v("ReentrantReadWriteLock")])])])])]),t._v(" "),v("li",[v("p",[t._v("性能层面")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("在没有竞争时，"),v("code",[t._v("synchronized")]),t._v(" 做了很多优化，如偏向锁、轻量级锁，性能不赖")])]),t._v(" "),v("li",[v("p",[t._v("在竞争激烈时，"),v("code",[t._v("Lock")]),t._v(" 的实现通常会提供更好的性能")])])])])]),t._v(" "),v("h3",{attrs:{id:"公平锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#公平锁"}},[t._v("#")]),t._v(" 公平锁")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("公平锁的公平体现")]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("已经处在阻塞队列")]),t._v("中的线程（不考虑超时）始终都是公平的，先进先出")])]),t._v(" "),v("li",[v("p",[t._v("公平锁是指"),v("strong",[t._v("未处于阻塞队列")]),t._v("中的线程来争抢锁，如果队列不为空，则老实到队尾等待")])]),t._v(" "),v("li",[v("p",[t._v("非公平锁是指"),v("strong",[t._v("未处于阻塞队列")]),t._v("中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的")])])])]),t._v(" "),v("li",[v("p",[t._v("公平锁会降低吞吐量，一般不用")])])]),t._v(" "),v("h3",{attrs:{id:"条件变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#条件变量"}},[t._v("#")]),t._v(" 条件变量")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构")])]),t._v(" "),v("li",[v("p",[t._v("与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制")])])]),t._v(" "),v("h2",{attrs:{id:"volatile"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[t._v("#")]),t._v(" volatile")]),t._v(" "),v("h3",{attrs:{id:"要求-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-5"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("掌握线程安全要考虑的三个问题")])]),t._v(" "),v("li",[v("p",[t._v("掌握 "),v("code",[t._v("volatile")]),t._v(" 能解决哪些问题")])])]),t._v(" "),v("h3",{attrs:{id:"原子性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[t._v("#")]),t._v(" 原子性")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("起因：多线程下，不同线程的"),v("strong",[t._v("指令发生了交错")]),t._v("导致的共享变量的读写混乱")])]),t._v(" "),v("li",[v("p",[t._v("解决：用悲观锁或乐观锁解决，"),v("code",[t._v("volatile")]),t._v(" 并不能解决原子性")])])]),t._v(" "),v("h3",{attrs:{id:"可见性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可见性"}},[t._v("#")]),t._v(" 可见性")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("起因：由于"),v("strong",[t._v("编译器优化、或缓存优化、或 CPU 指令重排序优化")]),t._v("导致的对共享变量所做的修改另外的线程看不到")])]),t._v(" "),v("li",[v("p",[t._v("解决：用 "),v("code",[t._v("volatile")]),t._v(" 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见")])])]),t._v(" "),v("h3",{attrs:{id:"有序性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有序性"}},[t._v("#")]),t._v(" 有序性")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("起因：由于"),v("strong",[t._v("编译器优化、或缓存优化、或 CPU 指令重排序优化")]),t._v("导致指令的实际执行顺序与编写顺序不一致")])]),t._v(" "),v("li",[v("p",[t._v("解决：用 "),v("code",[t._v("volatile")]),t._v(" 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果")])])]),t._v(" "),v("p",[v("strong",[t._v("注意：")])]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("volatile 变量写")]),t._v("加的屏障是阻止上方其它写操作越过屏障排到 "),v("strong",[t._v("volatile 变量写")]),t._v("之下")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("volatile 变量读")]),t._v("加的屏障是阻止下方其它读操作越过屏障排到 "),v("strong",[t._v("volatile 变量读")]),t._v("之上")])]),t._v(" "),v("li",[v("p",[t._v("volatile 读写加入的屏障只能防止同一线程内的指令重排")])])]),t._v(" "),v("h2",{attrs:{id:"悲观锁-vs-乐观锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁-vs-乐观锁"}},[t._v("#")]),t._v(" 悲观锁 vs 乐观锁")]),t._v(" "),v("h3",{attrs:{id:"要求-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-6"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ol",[v("li",[t._v("掌握悲观锁和乐观锁的区别")])]),t._v(" "),v("h3",{attrs:{id:"对比悲观锁与乐观锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对比悲观锁与乐观锁"}},[t._v("#")]),t._v(" 对比悲观锁与乐观锁")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("悲观锁的代表是 synchronized 和 Lock 锁")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】")])]),t._v(" "),v("li",[v("p",[t._v("线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能")])]),t._v(" "),v("li",[v("p",[t._v("实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会")])])])]),t._v(" "),v("li",[v("p",[t._v("乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】")])]),t._v(" "),v("li",[v("p",[t._v("由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换")])]),t._v(" "),v("li",[v("p",[t._v("它需要多核 cpu 支持，且线程数不应超过 cpu 核数")])])])])]),t._v(" "),v("h2",{attrs:{id:"hashtable-vs-concurrenthashmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashtable-vs-concurrenthashmap"}},[t._v("#")]),t._v(" Hashtable vs ConcurrentHashMap")]),t._v(" "),v("h3",{attrs:{id:"要求-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-7"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("掌握 Hashtable 与 ConcurrentHashMap 的区别")])]),t._v(" "),v("li",[v("p",[t._v("掌握 ConcurrentHashMap 在不同版本的实现区别")])])]),t._v(" "),v("h3",{attrs:{id:"hashtable-对比-concurrenthashmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashtable-对比-concurrenthashmap"}},[t._v("#")]),t._v(" Hashtable 对比 ConcurrentHashMap")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合")])]),t._v(" "),v("li",[v("p",[t._v("Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它")])]),t._v(" "),v("li",[v("p",[t._v("ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突")])])]),t._v(" "),v("h3",{attrs:{id:"concurrenthashmap-1-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-1-7"}},[t._v("#")]),t._v(" ConcurrentHashMap 1.7")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("数据结构："),v("code",[t._v("Segment(大数组) + HashEntry(小数组) + 链表")]),t._v("，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突")])]),t._v(" "),v("li",[v("p",[t._v("并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了")])]),t._v(" "),v("li",[v("p",[t._v("索引计算")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("假设大数组长度是 "),v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("semantics",[v("mrow",[v("msup",[v("mn",[t._v("2")]),v("mi",[t._v("m")])],1)],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^m")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.6644em"}}),v("span",{staticClass:"mord"},[v("span",{staticClass:"mord"},[t._v("2")]),v("span",{staticClass:"msupsub"},[v("span",{staticClass:"vlist-t"},[v("span",{staticClass:"vlist-r"},[v("span",{staticClass:"vlist",staticStyle:{height:"0.6644em"}},[v("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[v("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),v("span",{staticClass:"sizing reset-size6 size3 mtight"},[v("span",{staticClass:"mord mathnormal mtight"},[t._v("m")])])])])])])])])])])]),t._v("，key 在大数组内的索引是 key 的二次 hash 值的高 m 位")])]),t._v(" "),v("li",[v("p",[t._v("假设小数组长度是 "),v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("semantics",[v("mrow",[v("msup",[v("mn",[t._v("2")]),v("mi",[t._v("n")])],1)],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^n")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.6644em"}}),v("span",{staticClass:"mord"},[v("span",{staticClass:"mord"},[t._v("2")]),v("span",{staticClass:"msupsub"},[v("span",{staticClass:"vlist-t"},[v("span",{staticClass:"vlist-r"},[v("span",{staticClass:"vlist",staticStyle:{height:"0.6644em"}},[v("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[v("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),v("span",{staticClass:"sizing reset-size6 size3 mtight"},[v("span",{staticClass:"mord mathnormal mtight"},[t._v("n")])])])])])])])])])])]),t._v("，key 在小数组内的索引是 key 的二次 hash 值的低 n 位")])]),t._v(" "),v("li",[v("p",[t._v("扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍")])])])]),t._v(" "),v("li",[v("p",[t._v("Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准")])])]),t._v(" "),v("h3",{attrs:{id:"concurrenthashmap-1-8"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-1-8"}},[t._v("#")]),t._v(" ConcurrentHashMap 1.8")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("数据结构："),v("code",[t._v("Node 数组 + 链表或红黑树")]),t._v("，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能")])]),t._v(" "),v("li",[v("p",[t._v("并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容")])]),t._v(" "),v("li",[v("p",[t._v("扩容条件：Node 数组满 3/4 时就会扩容")])]),t._v(" "),v("li",[v("p",[t._v("扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode")])]),t._v(" "),v("li",[v("p",[t._v("扩容时并发 get")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞")])]),t._v(" "),v("li",[v("p",[t._v("如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变")])]),t._v(" "),v("li",[v("p",[t._v("如果链表最后几个元素扩容后索引不变，则节点无需复制")])])])]),t._v(" "),v("li",[v("p",[t._v("扩容时并发 put")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞")])]),t._v(" "),v("li",[v("p",[t._v("如果 put 的线程操作的链表还未迁移完成，即头节点不是ForwardingNode，则可以并发执行")])]),t._v(" "),v("li",[v("p",[t._v("如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容")])])])]),t._v(" "),v("li",[v("p",[t._v("与 1.7 相比是懒惰初始化")])]),t._v(" "),v("li",[v("p",[t._v("capacity 代表预估的元素个数，capacity / factory 来计算出初始数组大小，需要贴近 "),v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("semantics",[v("mrow",[v("msup",[v("mn",[t._v("2")]),v("mi",[t._v("n")])],1)],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^n")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.6644em"}}),v("span",{staticClass:"mord"},[v("span",{staticClass:"mord"},[t._v("2")]),v("span",{staticClass:"msupsub"},[v("span",{staticClass:"vlist-t"},[v("span",{staticClass:"vlist-r"},[v("span",{staticClass:"vlist",staticStyle:{height:"0.6644em"}},[v("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[v("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),v("span",{staticClass:"sizing reset-size6 size3 mtight"},[v("span",{staticClass:"mord mathnormal mtight"},[t._v("n")])])])])])])])])])])])])]),t._v(" "),v("li",[v("p",[t._v("loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3/4")])]),t._v(" "),v("li",[v("p",[t._v("超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容")])])]),t._v(" "),v("h2",{attrs:{id:"threadlocal"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal"}},[t._v("#")]),t._v(" ThreadLocal")]),t._v(" "),v("h3",{attrs:{id:"要求-8"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#要求-8"}},[t._v("#")]),t._v(" 要求")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("掌握 ThreadLocal 的作用与原理")])]),t._v(" "),v("li",[v("p",[t._v("掌握 ThreadLocal 的内存释放时机")])])]),t._v(" "),v("h3",{attrs:{id:"作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题")])]),t._v(" "),v("li",[v("p",[t._v("ThreadLocal 同时实现了线程内的资源共享")])])]),t._v(" "),v("h3",{attrs:{id:"原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),v("p",[t._v("每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中")])]),t._v(" "),v("li",[v("p",[t._v("调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值")])]),t._v(" "),v("li",[v("p",[t._v("调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值")])])]),t._v(" "),v("p",[t._v("ThreadLocalMap 的一些特点")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("key 的 hash 值统一分配")])]),t._v(" "),v("li",[v("p",[t._v("初始容量 16，扩容因子 2/3，扩容容量翻倍")])]),t._v(" "),v("li",[v("p",[t._v("key 索引冲突后用开放寻址法解决冲突")])])]),t._v(" "),v("h3",{attrs:{id:"弱引用-key"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#弱引用-key"}},[t._v("#")]),t._v(" 弱引用 key")]),t._v(" "),v("p",[t._v("ThreadLocalMap 中的 key 被设计为弱引用，原因如下")]),t._v(" "),v("ol",[v("li",[t._v("Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存")])]),t._v(" "),v("h3",{attrs:{id:"内存释放时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存释放时机"}},[t._v("#")]),t._v(" 内存释放时机")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("被动 GC 释放 key")]),t._v(" "),v("ol",[v("li",[t._v("仅是让 key 的内存释放，关联 value 的内存并不会释放")])])]),t._v(" "),v("li",[v("p",[t._v("懒惰被动释放 value")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("get key 时，发现是 null key，则释放其 value 内存")])]),t._v(" "),v("li",[v("p",[t._v("set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关")])])])]),t._v(" "),v("li",[v("p",[t._v("主动 remove 释放 key，value")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存")])]),t._v(" "),v("li",[v("p",[t._v("推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收")])])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);